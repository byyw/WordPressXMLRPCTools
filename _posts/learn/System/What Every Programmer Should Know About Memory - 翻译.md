---
title: What Every Programmer Should Know About Memory（翻译）
tags:
- 文献
- 内存
categories:
- 学习
- 操作系统
---

# What Every Programmer Should Know About Memory（翻译）

[What Every Programmer Should Know About Memory](https://akkadia.org/drepper/cpumemory.pdf)

# 摘要
随着CPU内核变得更快和更多，现在，并且在一段时间内，限制许多程序的因素是内存访问。随着越来越多复杂的内存处理和加速技术，例如CPU缓存，硬件设计师被提出，然而他们如果没有程序员的帮助，就不能最好的工作。不幸的是对于大多数程序员而言，使用计算机内存子系统或CPU缓存的结构、成本都不能很好的理解。而本文将会说明用于现代商业硬件的内存子系统结构，阐明为什么开发CPU缓存，他们怎么工作，以及程序利用他们做什么才能获取最佳性能。

# 介绍
在早期，计算机是很简单的。CPU、内存、大容量存储和网络接口等这些各种各样的系统组件都一起发展，并且他们的性能相当平衡。例如，在传输数据上，内存和网络接口不比CPU慢（很多）。

一旦计算机的基本结构稳定和硬件开发人员集中于优化单个子系统。突然一些计算机组件的性能显著的落后，并出现瓶颈。特别是在大容量存储和内存子系统相对于其他组件发展缓慢尤其如此。

大容量存储器的缓慢更多通过使用软件技术来处理：操作系统尽可能在比硬盘存取速度快一个数量级的主内存访问数据（或被数据访问），缓存被添加到存储设备本身，这不需要改变操作系统就能提高性能。为了本文的目的，我们将不会为了大容量存储的存取而深入程序最优化的细节。

不像存储子系统，移除作为瓶颈的主内存已经被证明非常困难，几乎所有解决方案都要求改变硬件。

现在这些改变大体以以下形式出现：
- RAM硬件设计（速度和并行）
- 存储控制器设计
- CPU缓存
- 设备的直接存储访问

在很大程度上，这份文件将涉及CPU缓存和一些内存控制设计的影响。在探索这些主题的过程中，我们将探索直接存储访问(RMA)，并将其带入更大的画面。然而，我们要从当今的商业硬件的设计概述开始。这是我们理解最高效运用存储子系统问题与极限的先决条件。我们也将了解，在一些细节中，RMA的不同类型和解释为什么这些不同仍然存在。

这份文件绝不是全面的和最终的。它仅限于商业硬件并进一步限于该硬件的一个子集。同时，为了这篇论文的目的，许多主题将会被足够详细地讨论。对于一些主题，推荐读者去寻找更详细地文献。

当涉及到操作系统具体的细节和问题时，本文仅描述LINUX，绝不包含任何关于其他操作系统的信息。作者没有兴趣讨论它对其他操作系统的影响。如果读者认为她必须使用不同的操作系统，他们必须去对应的供应商，要求他们写一份与本文类似的文件。

